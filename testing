
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>


#define CORNER_SCORE 100
#define EDGE_SCORE 40
#define CORNER_ENABLING_SCORE 30


//Function #1 Printing the play board:

void printBoard(char board[][26], int n){

    int i = 0, row = 0, col = 0;
    char start = 'a';

    printf("  ");
    for(i = 0; i < n; i++){
        printf("%c", start + i);
     
    }                                           // Prints the letter indeces for the columns
    printf("\n");        

    for (row = 0; row < n; row++){
     
         printf("%c ", start + row);            // Prints the letter index for each column
         
         for(col = 0; col < n; col++){
            printf("%c", board[row][col]);
         }                                      // Prints all columns for a particular row
         
         printf("\n");
    }                                           // This loop cycles through the rows


}


// Function #2 find the numeric index of an inputted letter position:
int numIndex(char c){              
    char startingValue = 'a';
    return (int) (c - startingValue);
}



// Function #3 find the letter position of an inputted numeric index:
char charIndex(int num){  
    return (char) ('a' + num);
}




// Function #4 set intermediate board configuration
void setBoard(char board[][26], int n){          

    int row = 0, col = 0;
    for (row = 0; row < n; row++){
         for (col = 0; col < n; col++){
              if( ((row == n/2 - 1)&&(col == n/2 - 1)) || ((row == n/2) && (col == n/2)) ){
                board[row][col] = 'W';
              }
              else if ( ((row == n/2 - 1)&&(col == n/2)) || ((row == n/2)&&(col == n/2 -1)) ){
                board[row][col] = 'B';
              }
              else{
                board[row][col] = 'U';
              }
         }
     
    }


}




// Function #5 check to see if position is in bounds
bool positionInBounds(int n, int row, int col){
    return (row >= 0 && row < (n) && col >= 0 && col < (n));

}



// Function #6 checks if move is legal in a particular direction specified by deltaRow and deltaCol
bool checkLegalInDirection( char board[][26], int n, int row, int col, char colour, int deltaRow, int deltaCol){
   
    if (deltaRow == 0 && deltaCol == 0){                                                        // Retun false when both increments are 0 becasue there is
        return false;                                                                           // no such diretion.
    }
   
    int step = 1;
    char oppColour;
    if (colour == 'W'){
        oppColour = 'B';
    }
    else {
        oppColour = 'W';
    }
     
    bool check = positionInBounds(n, row + (step + 1)*deltaRow, col + (step + 1)*deltaCol);     // Checks to see if within the specified direction
    if (!check){                                                                                // the next two spaces are within bounds. If they are not
        return false;                                                                           // within bounds of the board, the player cannot play the move for
    }                                                                                           // that direction.

    while (board[row + step*deltaRow][col + step*deltaCol] == oppColour){                       // If the next place within the direction line is of opposite colour
                                                                                                // keep checking. If not, then the move is not valid for the direction
     
         char next = board[row + (step + 1)*deltaRow][col + (step + 1)*deltaCol];               // Stores second place in line into variable next
         if (next == colour){
            return true;                                                                        // If second place in line has a tile of player's color, then move is valid
         }
         
         if (next == 'U'){                                                                      // If second place in line is empty, move is invalid in that direction
            return false;
         }
                               
         step++;                                                                                    // If n + 1 th place in line is of the same color
         bool check = positionInBounds(n, row + (step + 1)*deltaRow, col + (step + 1)*deltaCol);    // then increment step by one to check the n + 2 th place
         if (!check){
            return false;                                                                           // If the n + 2 th place is out of bounds, then move is invalid in
         }                                                                                          // that direction.
     
    }

    return false;
 
}




// Function #7 checks to see if a move is valid
bool checkValidMove( char board[][26], int n, int row, int col, char colour){

    if (board[row][col] != 'U'){
        return false;
    }

    int deltaRow = -1, deltaCol = -1;
    bool check;
    for (deltaRow = -1; deltaRow <= 1; deltaRow++){
         for (deltaCol = -1; deltaCol <= 1; deltaCol++){
              check = checkLegalInDirection(board, n, row, col, colour, deltaRow, deltaCol);
              if (check){
                return true;
              }
         }
         
    }
     return false;


}




// Function #8 for requesting input from the user
bool getInput(char board[][26], int n, char human, int* ptrRow, int* ptrCol){

    printf("Enter move for colour %c (RowCol): ", human);

    scanf(" %d%d", ptrRow, ptrCol);

    if (!checkValidMove(board, n, numIndex(*ptrRow), numIndex(*ptrCol), human)){
         printf("Invalid move.\n");
         return false;
    }
     return true;

}


// Function #9 flip function
void flip(char board[][26], int n, int row, int col, char colour){

    int deltaRow, deltaCol = -1, step = 1;

    for(deltaRow = -1; deltaRow <= 1; deltaRow++){
     for(deltaCol = -1; deltaCol <= 1; deltaCol++){
      if(checkLegalInDirection(board, n, row, col, colour, deltaRow, deltaCol)){
          step = 1;
       while(board[row + step*deltaRow][col + step*deltaCol] != colour){
        board[row + step*deltaRow][col + step*deltaCol] = colour;
        step++;
       
       }
      }
     }
    }


}


// Function #10: checking available moves function:
bool checkAvailableMoves(char board[][26], int n, char colour){

    int row = 0, col = 0;
    for(row = 0; row < n; row++){
         for(col = 0; col < n; col++){
              if (checkValidMove(board, n, row, col,colour)){
                return true;
              }
         }    
    }

    return false;

}







//Function : makes computer play
/*bool computerPlay(char board[][26], int n, int* ptrRowPlay, int* ptrColPlay, char compcolour){

    int row = 0, col = 0, newScore = 0, oldScore = 0;
    bool canPlay = false;

    for(row = 0; row < n; row++){
         for(col = 0; col < n; col++){
              if(checkValidMove(board, n, row, col, compcolour)){
                   canPlay = true;
                   newScore = calculateMoveScore(board, n, row, col, compcolour);
                   if(newScore > oldScore){
                        oldScore = newScore;
                        *ptrRowPlay = row;
                        *ptrColPlay = col;
                   }
              }
         }
    }

    return canPlay;

}*/


int checkWinner(char board[][26], int n, char compColour, char humanColour){

    int compCount = 0, humanCount = 0, row = 0, col = 0;
    for (row = 0; row < n; row++){
         for (col = 0; col < n; col++){
              if (board[row][col] == compColour){
               compCount ++;
          }
          else if (board[row][col] == humanColour){
            humanCount ++;
          }
         }
    }

    if (compCount > humanCount){
        return -1;
    }

    if (humanCount > compCount){
        return 1;
    }

    else{
        return 0;
    }
}



bool checkGameOver(char board[][26], int n, int* ptrWinner, int totalTurns, char compColour, char humanColour){

    bool gameOver = false;
     if( (!checkAvailableMoves(board, n, 'W') && !checkAvailableMoves(board, n, 'B')) || (totalTurns == n*n) ){
          gameOver = true;
          *ptrWinner = checkWinner(board, n, compColour, humanColour);
     }
     return gameOver;
}



//Funcion XX: Player switch function
char switchPlayer(char currentPlayer){

    char nextPlayer = 0;
    if (currentPlayer == 'W'){
     nextPlayer = 'B';
    }

    else{
     nextPlayer = 'W';
    }

    return nextPlayer;
}






void resetBoard (char newBoard[][26], char originalBoard[][26], int n){
	
	int row = 0, col = 0;
	for (row = 0; row < n; row++){
		for(col = 0; col < n; col++){
			newBoard[row][col] = originalBoard[row][col];
		}
		
	}
	
}


// Function #4 set intermediate board configuration
void setIntermediate(char board[][26]){         
    printf("Enter board configuration:\n");
    char c1 = 0, c2 = 0, c3 = 0;
    do{
    
         scanf("\n%c%c%c", &c1, &c2, &c3);                      // Scans input from the user
        
         if (c1 != '!' && c2 != '!' && c3 != '!'){
              if (c1 == '!' || c2 == '!' || c3 == '!'){         // Checks for invalid input
                printf("Invalid move.");
              }
              else if(!(c1 == 'B' || c1 == 'W')){
                printf("Invalid move.");                        // Checks for invalid input
              }
              else {
                board[numIndex(c2)][numIndex(c3)] = c1;         // Places a tile of the indicated color in the indicated position
              }
         }
    
    }while(!(c1 == '!' && c2 == '!' && c3 == '!'));             // Keep requesting for input until user enters !!!

}


/********************************************************************************************************************************/
//Functions that check to see if my ability to win is higher:



// Counts how many tiles I can flip in this move
int flipCount(char board[][26], int n, int row, int col, char colour){
	
	int deltaRow, deltaCol = -1, step = 1, score = 0;
	
	for(deltaRow = -1; deltaRow <= 1; deltaRow++){
		for(deltaCol = -1; deltaCol <= 1; deltaCol++){
			if(checkLegalInDirection(board, n, row, col, colour, deltaRow, deltaCol)){
                step = 1;
				while(board[row + step*deltaRow][col + step*deltaCol] != colour){
					score++;
					step++;
					
				}
			}
		}
	}

	return score;
}



int countCornerScore(int n, int row, int col){
	
	if( (row == 0 && col == 0) || (row == n-1 && col == n-1) || (row == 0 && col == n) || (row = n-1 && col == 0) ){
		return CORNER_SCORE;
	}
	return 0;
	
}

int countEdgeScore(int n, int row, int col){
	
	if (row == 0 || row == n-1 || col == 0 || col == n-1){
		return EDGE_SCORE;
		
	}
	return 0;
	
}

int countCornerEnablingScore(char scratchboard[][26], int n, int rowPlay, int colPlay, char colour){ // assumes n is at least 6
	
	scratchboard[rowPlay][colPlay] = colour;
	flip(scratchboard, n, rowPlay, colPlay, colour);
	
	int score = 0;
	int row = 0, col = 0;
	int i = 0;
	int j = 0;
	
	
	
	for (i = 0; i <= 1; i++){
		
		for (j = 0; j<=1; j++){
			
			for (col = 0 + j*(n-3); col < 3 + j*(n-3); col++){
				if(scratchboard[2 + i*(n-5)][col] == colour){
					score += CORNER_ENABLING_SCORE;
				}
			}

			for (row = 0 + j*(n-2); row < 2+j*(n-2); row++){
				if(scratchboard[row][2+ i*(n-5)] == colour){
					score += CORNER_ENABLING_SCORE;
				}
			}
			
		}
	}


	return score;
}



int getBulkSize(char board[][26], int n, char colour){
	
	
	int row = 0, col = 0;

	
	
	// Following is for top left corner:
	int bulkSize1 = 0;
	int oldRowCount = 0, oldColCount = 0;
	int rowCount = n  , colCount = n ;
	
	int i = 0;
	do{ 
		oldRowCount = rowCount;
		oldColCount = colCount;
		if (board[i][i] == colour){
			rowCount = i, colCount = i;
			 col = i;
			while (board[i][col] == colour && (col < oldColCount || (col == oldColCount && col < oldRowCount)) ){				//Checks tiles down the row

					if(col!=i){
						colCount ++;
					}
					
					bulkSize1 += 1;
				
				col += 1;
				
			}
			
			row = i + 1;
			while (board[row][i] == colour && (row < oldRowCount || (row == oldRowCount && row <= oldColCount))){				//Checks tiles down the row
				
					rowCount ++;
					bulkSize1 += 1;
				row ++;
				
			}
		}
		i++;
	}while(board[i][i] == colour);
	
	
	
//	Top right corner:
/*
	int bulkSize2 = 0;
	oldRowCount = 0, oldColCount = 0;
	rowCount = n - 1, colCount = 0;
	
	i = 0;
	do{ 
		oldRowCount = rowCount;
		oldColCount = colCount;
		if (board[i][n - i] == colour){
			rowCount = i, colCount = i;
			 bulkSize2 += 1;
			while (board[i][col] == colour && (col < n - oldColCount || (col == n  - oldColCount && col <= oldRowCount))){				//Checks tiles down the row
				col = i + 1;
				if(board[i][col] == colour){
					colCount ++;
					bulkSize2 += 1;
				}
				
			}
			
			while (board[row][i] == colour && (row < oldRowCount || (row == oldRowCount && row <= n - oldColCount))){				//Checks tiles down the row
				row = i + 1;
				if(board[row][i] == colour){
					colCount ++;
					bulkSize2 += 1;
				}
				
			}
		}
		i++;
	}while(board[i][ n - i] == colour);
	
	
	//	Bottom left corner:
	int bulkSize3 = 0;
	oldRowCount = 0, oldColCount = 0;
	rowCount = 0, colCount = n - 1;
	
	
	i = 0;
	do{ 
		oldRowCount = rowCount;
		oldColCount = colCount;
		if (board[n - i][i] == colour){
			rowCount = i, colCount = i;
			 bulkSize3 += 1;
			while (board[i][col] == colour && (col < oldColCount || (col == oldColCount && col <= n - oldRowCount))){				//Checks tiles down the row
				col = i + 1;
				if(board[i][col] == colour){
					colCount ++;
					bulkSize3 += 1;
				}
				
			}
			
			while (board[row][i] == colour && (row < n - oldRowCount || (row == n - oldRowCount && row <= oldColCount))){				//Checks tiles down the row
				row = i + 1;
				if(board[row][i] == colour){
					colCount ++;
					bulkSize3 += 1;
				}
				
			}
		}
		i++;
	}while(board[n - i][i] == colour);
	
	
	//	Bottom right corner:
	int bulkSize4 = 0;
	oldRowCount = 0, oldColCount = 0;
	rowCount = n - 1, colCount = n - 1;
	
	
	i = 0;
	do{ 
		oldRowCount = rowCount;
		oldColCount = colCount;
		if (board[n - i][ n - i] == colour){
			rowCount = i, colCount = i;
			 bulkSize4 += 1;
			while (board[i][col] == colour && (col < n - oldColCount || (col == n - oldColCount && col <= n - oldRowCount))){				//Checks tiles down the row
				col = i + 1;
				if(board[i][col] == colour){
					colCount ++;
					bulkSize4 += 1;
				}
				
			}
			
			while (board[row][i] == colour && (row < n - oldRowCount || (row == n - oldRowCount && row <= n - oldColCount))){				//Checks tiles down the row
				row = i + 1;
				if(board[row][i] == colour){
					colCount ++;
					bulkSize4 += 1;
				}
				
			}
		}
		i++;
	}while(board[n - i][n - i] == colour);
*/	
	
	return bulkSize1 ;//+ bulkSize2 + bulkSize3 + bulkSize4;
	
}



int countBulkIncreaseScore(char scratchBoard[][26], int n, int row, int col, char colour){
	
	int factor = 2; // need to decide on
	
	int bulk1 = getBulkSize(scratchBoard, n, colour);
	scratchBoard[row][col] = colour;
	flip(scratchBoard, n, row, col, colour);
	int bulk2 = getBulkSize(scratchBoard, n, colour);
	
	int deltaBulk = bulk2 - bulk1;
	
	return deltaBulk*factor;
	
	
}

/*****************************************************************************************************************************************************************/


/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/
/*****************************************************************************************************************************************************************/


/****************************************************************************************************************************************************************/
//Funtions that check if opponent has a better chance of winning

int countHumanCornerGiving(char scratchboard[][26], int n, int rowPlay, int colPlay, char compcolour, char humanColour){
	
	
	int cornerCount = 0;
	scratchboard[rowPlay][colPlay] = compcolour;
	flip(scratchboard, n, rowPlay, colPlay, compcolour);
	
	int i = 0, j = 0;
	
	while ( j <= n - 1){
		
		i = 0;
		while ( i <= n - 1){
			if (checkValidMove(scratchboard, n, i, j, humanColour)){
				cornerCount ++;
			}
			i += n - 1;
		}
		j += n - 1;
	}
	
	return (-30)*cornerCount;
}



int humanFlipCount(char scratchboard[][26], int n, int rowPlay, int colPlay, char compcolour, char humanColour){
	
	scratchboard[rowPlay][colPlay] = compcolour;
	flip(scratchboard, n, rowPlay, colPlay, compcolour);
	int score = 0 , tempscore = 0;
	
	int row = 0, col = 0;
	for (row = 0; row < n; row++){
		for(col = 0; col < n; col ++){
			if(checkValidMove(scratchboard, n, row, col, humanColour)){
				tempscore = flipCount(scratchboard, n, row, col, humanColour);
				if(tempscore >= score){
					score = tempscore;
				}
			}
			
		}
	}
	
	return -score; 
	
	
	
}





/********************************************************************************************************************************/




int smartScore(char board[][26], int n, int row, int col, char compColour, char humanColour, int gameTurn){
	
	char scratchBoard [26][26] = {{0}};
	resetBoard(scratchBoard, board, n);
	int flipscore = flipCount(board, n, row, col, compColour);
	int cornerScore = countCornerScore(n, row, col);
	int edgeScore = countEdgeScore(n, row, col);
	int cornerEnablingScore = countCornerEnablingScore(scratchBoard, n, row, col, compColour);
	resetBoard(scratchBoard, board, n);
	int bulkIncreaseScore = countBulkIncreaseScore(scratchBoard, n, row, col, compColour);
	
	resetBoard(scratchBoard, board, n);
	int humanCornerGiving = countHumanCornerGiving(scratchBoard, n, row, col, compColour, humanColour);
	resetBoard(scratchBoard, board, n);
	int humanFlipScore = humanFlipCount(scratchBoard, n, row, col, compColour, humanColour);
	
	int c1 = 1, c2 = 1, c3 = 1, c4 = 1, c5 = 1, c6 = 1, c7 = 1;
	
	return c1*flipscore + c2*cornerScore + c3*edgeScore + c4*cornerEnablingScore + c5*bulkIncreaseScore + c6*humanCornerGiving + c7*humanFlipScore;
	
	
}









































// Junk code:

	/*	int i = 0;
		
		if(colCount >= rowCount){
			for(i = 1; i < rowCount; i++){
				for(col = 1; col < colCount - i; col++){
					
					if(board[i][col] == colour){
						bulkSize ++;
					}
					else{
						break;
					}
					
				}
			}
		}
		
		else{
			for(i = 1; i < colCount; i++){
				for(row = 1; row < colCount - i; row++){
					
					if(board[row][i] == colour){
						bulkSize ++;
					}
					else{
						break;
					}
					
				}
			}
		}*/






int minimax (char board[][26], int n, int row, int col, int depth, int bestPossibleScore, int worstPossibleScore, bool maxPlayer, char compColour, char humanColour, int gameTurnCounter){		// status: true for maximizing player; false for minimizing player
	
		int winner = 0;
		if (depth == 0 || checkGameOver(board, n, &winner, gameTurnCounter, compColour, humanColour)){
			return smartScore(board, n, row, col, compColour, humanColour, gameTurnCounter);
		}
		gameTurnCounter++;
		
		int score = 0;
		char scratchBoard[26][26];
		resetBoard(scratchBoard, board, n);
		
		if(maxPlayer){
			int maxScore = INT_MIN;
			int i = 0, j = 0;
            scratchBoard[row][col] = humanColour;
			
			while(i < n){
				while(j < n){
					if (checkValidMove(scratchBoard, n, i, j, compColour)){
						
						score = minimax(scratchBoard, n, i, j, depth - 1, bestPossibleScore, worstPossibleScore, false, compColour, humanColour, gameTurnCounter);
						maxScore = fmax(maxScore, score);
						bestPossibleScore = fmax(bestPossibleScore, score);
						if (worstPossibleScore <= bestPossibleScore){
							break;
						}
						
					}
                    j++;
				}
				i++;
				
			}
			return maxScore;
		}
		
		else {
			int minScore = INT_MAX;
			int i = 0, j = 0;
            scratchBoard[row][col] = compColour;
			
			while(i < n){
				while(j < n){
					if (checkValidMove(scratchBoard, n, i, j, humanColour)){
						
						score = minimax(scratchBoard, n, i, j, depth - 1, bestPossibleScore, worstPossibleScore, true, compColour, humanColour, gameTurnCounter);
						minScore = fmin (minScore, score);
						worstPossibleScore = fmin(worstPossibleScore, score);
						if(worstPossibleScore <= bestPossibleScore){
							break;
						}
					}
					j++;
				}
				i ++;
			}
			return minScore;
		}
		
	
}



bool computerPlay(char board[][26], int n, int* ptrRowPlay, int* ptrColPlay, char compColour, char humanColour, int gameTurnCounter){

    int row = 0, col = 0, newScore = 0, oldScore = INT_MIN;
    bool canPlay = false;

    for(row = 0; row < n; row++){
         for(col = 0; col < n; col++){
              if(checkValidMove(board, n, row, col, compColour)){
                   canPlay = true;
                   newScore = minimax(board, n, row, col, 4, INT_MIN, INT_MAX, false, compColour, humanColour, gameTurnCounter);
                   if(newScore > oldScore){
                        oldScore = newScore;
                        *ptrRowPlay = row;
                        *ptrColPlay = col;
                   }
              }
         }
    }

    return canPlay;

}





int main(void){

    int n = 0;
	printf("Enter board dimension: ");
    scanf("%d", &n);
	char board[26][26];
	char comp = 0, human = 0;
	printf("Computer plays (B/W): ");
	scanf(" %c", &comp);
	if (comp == 'B'){
		human = 'W';
	}
	else{
		human = 'B';
	}
	
	setBoard(board, n);
    printBoard(board, n);
	
	bool gameOver = false;
	int humanRow, humanCol;
	int compRow, compCol;
	int totalTurns = 0, turn = 0;
	int winner = 0;
	
	if (comp == 'B'){
		turn = -1;
	}
	else{
		turn = 1;
	}
    
	while (!gameOver){
		totalTurns ++;
		if (turn == 1){
			if(checkAvailableMoves(board, n, human)){
				bool check = getInput(board, n, human, &humanRow, &humanCol);
				if(check){
					board[numIndex(humanRow)][numIndex(humanCol)] = human;
					flip(board, n, numIndex(humanRow), numIndex(humanCol), human);
				}
				else{
					printf("%c player wins.\n", comp);
					return 0;
				}
				
			}
			else{
				printf("%c has no valid move.\n", human);
			}
		}


		if (turn == -1){
			if(computerPlay(board, n, &compRow, &compCol, comp, human, totalTurns)){
				printf("Computer places %c at %c%c.\n", comp, charIndex(compRow), charIndex(compCol));
				board[compRow][compCol] = comp;
				flip(board, n, compRow, compCol, comp);
			}
			else{
				printf("%c has no valid move\n", comp);
			}

			
		}
		
		printBoard(board, n);
		
		
		gameOver = checkGameOver(board,n, &winner, totalTurns, comp, human);
		turn *= -1;
	}
	
	if (winner == -1){
		printf("%c player wins.\n", comp);
	}
	else if (winner == 1){
		printf("%c player wins.\n", human);
	}
	else{
		printf("Draw!\n");
	}
	
	return 0;
}
